<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>the-mikedavis</title>
    <link rel="self" type="application/atom+xml" href="https://the-mikedavis.github.io/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://the-mikedavis.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-08-03T00:00:00+00:00</updated>
    <id>https://the-mikedavis.github.io/atom.xml</id>
    <entry xml:lang="en">
        <title>Uploading a file to S3 without reading it</title>
        <published>2025-08-03T00:00:00+00:00</published>
        <updated>2025-08-03T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://the-mikedavis.github.io/posts/ktls-sendfile-s3/"/>
        <id>https://the-mikedavis.github.io/posts/ktls-sendfile-s3/</id>
        
        <content type="html" xml:base="https://the-mikedavis.github.io/posts/ktls-sendfile-s3/">&lt;p&gt;This post covers uploading a file to S3. It&#x27;s pretty simple: make an HTTP&#x2F;1.1 &lt;code&gt;PUT&lt;&#x2F;code&gt; request and now your file is in &lt;em&gt;the cloud&lt;&#x2F;em&gt; ðŸª„.&lt;&#x2F;p&gt;
&lt;p&gt;What could possibly be interesting about something so mundane? Well, we&#x27;re going to leverage the Linux kernel to do it in an unnecessarily efficient way. (Note: I think FreeBSD also supports this but I haven&#x27;t tried it.)&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ll be looking at a novel way - used by no existing AWS SDK clients to my knowledge - to upload to S3.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;how-you-d-normally-do-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#how-you-d-normally-do-it&quot; aria-label=&quot;Anchor link for: how-you-d-normally-do-it&quot;&gt;How you&#x27;d normally do it&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;AWS S3 has a REST HTTP API which accepts HTTP&#x2F;1.1. You can add an &quot;object&quot; (basically a file) to the &quot;bucket&quot; (kinda like a file system) with a &lt;a href=&quot;https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;AmazonS3&#x2F;latest&#x2F;API&#x2F;API_PutObject.html&quot;&gt;PutObject&lt;&#x2F;a&gt; request.&lt;&#x2F;p&gt;
&lt;p&gt;HTTP&#x2F;1.1 is super simple. To quote &lt;a href=&quot;https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc7230&quot;&gt;RFC 7230&lt;&#x2F;a&gt;, the syntax looks like so:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;HTTP-message   = start-line
&lt;&#x2F;span&gt;&lt;span&gt;                 *( header-field CRLF )
&lt;&#x2F;span&gt;&lt;span&gt;                 CRLF
&lt;&#x2F;span&gt;&lt;span&gt;                 [ message-body ]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For example inserting an object could look like this (quoting the AWS documentation):&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;PUT &#x2F;example-object HTTP&#x2F;1.1
&lt;&#x2F;span&gt;&lt;span&gt;Host: example-bucket.s3.&amp;lt;Region&amp;gt;.amazonaws.com
&lt;&#x2F;span&gt;&lt;span&gt;Accept: *&#x2F;*
&lt;&#x2F;span&gt;&lt;span&gt;Authorization: &amp;lt;authorization string&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;Date: Thu, 22 Sep 2016 21:58:13 GMT
&lt;&#x2F;span&gt;&lt;span&gt;x-amz-tagging: tag1=value1&amp;amp;tag2=value2
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[... bytes of object data] 
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;start-line&lt;&#x2F;code&gt; is the HTTP method, path, and &quot;HTTP&#x2F;1.1&quot; all separated by spaces. Then you have a set of headers. Then an empty line and then the body. All of these lines use the CRLF line-ending (&lt;code&gt;\r\n&lt;&#x2F;code&gt;). Open a TLS socket to this S3 endpoint and send that binary data (after TLS encryption) and you can upload to S3.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A quick aside: calculating the authorization header is a little bit involved. I will totally skip over it in this post. The proper docs are &lt;a href=&quot;https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;AmazonS3&#x2F;latest&#x2F;API&#x2F;sig-v4-header-based-auth.html&quot;&gt;here&lt;&#x2F;a&gt; and a simple Erlang implementation is included in the gist linked later.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;In Erlang this might look like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;erlang&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-erlang &quot;&gt;&lt;code class=&quot;language-erlang&quot; data-lang=&quot;erlang&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;upload&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;File&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;ok&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Socket&lt;&#x2F;span&gt;&lt;span&gt;} = ssl:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;connect&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;s3.us-east-2.amazonaws.com&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;443&lt;&#x2F;span&gt;&lt;span&gt;, []),
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;%% Send an HTTP&#x2F;1.1 header based on the file&amp;#39;s size (content-length header)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;%% and auth parameters like the secret access key.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;ok &lt;&#x2F;span&gt;&lt;span&gt;= ssl:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;send&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Socket&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;http1_header&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;File&lt;&#x2F;span&gt;&lt;span&gt;)),
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;%% Read the file into memory.
&lt;&#x2F;span&gt;&lt;span&gt;    {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;ok&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;FileContents&lt;&#x2F;span&gt;&lt;span&gt;} = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;file&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;read_file&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;File&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;%% And then send it on the socket, as the body.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;ok &lt;&#x2F;span&gt;&lt;span&gt;= ssl:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;send&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Socket&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;FileContents&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;%% Receiving a response is overrated. Let&amp;#39;s just close the socket.
&lt;&#x2F;span&gt;&lt;span&gt;    ssl:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;close&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Socket&lt;&#x2F;span&gt;&lt;span&gt;).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Erlang has an odd Prolog-like syntax but hopefully you get the gist. We open a connection to S3 and send an HTTP&#x2F;1.1 PUT request with the file&#x27;s contents as the HTTP&#x2F;1.1 body.&lt;&#x2F;p&gt;
&lt;p&gt;This is nice and straightforward but it means that we need to read the entire file contents into memory in order to upload the file. We could read in smaller chunks or use a chunked transfer-encoding or even a fancy &lt;a href=&quot;https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;AmazonS3&#x2F;latest&#x2F;userguide&#x2F;mpuoverview.html&quot;&gt;multi-part upload&lt;&#x2F;a&gt;. No matter how we slice it though, we need to read the file into our Erlang program&#x27;s memory.&lt;&#x2F;p&gt;
&lt;p&gt;Or do we?!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;sendfile-2&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#sendfile-2&quot; aria-label=&quot;Anchor link for: sendfile-2&quot;&gt;sendfile(2)&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;sendfile(2)&lt;&#x2F;code&gt; is a system call which a &quot;userspace&quot; program (a program above the kernel) can use to instruct the kernel to copy the contents of one file descriptor to another. You can use sendfile against a TCP socket to instruct the kernel to write a file&#x27;s contents to a network connection. The advantage of this is that you don&#x27;t ever need to read the file contents into a buffer in the Erlang program&#x27;s memory. It&#x27;s all up to the kernel to move those bytes around. Especially since Erlang is a garbage-collected language, a program can save some memory and work by using sendfile instead of reading and writing to a socket itself.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;erlang&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-erlang &quot;&gt;&lt;code class=&quot;language-erlang&quot; data-lang=&quot;erlang&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;upload&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;File&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;ok&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Socket&lt;&#x2F;span&gt;&lt;span&gt;} = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;gen_tcp&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;connect&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my-unencrypted-host.example.com&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80&lt;&#x2F;span&gt;&lt;span&gt;, []),
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;ok &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;gen_tcp&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;send&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Socket&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;http1_header&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;File&lt;&#x2F;span&gt;&lt;span&gt;)),
&lt;&#x2F;span&gt;&lt;span&gt;    {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;ok&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_BytesWritten&lt;&#x2F;span&gt;&lt;span&gt;} = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;file&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sendfile&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;File&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Socket&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;gen_tcp&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;close&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Socket&lt;&#x2F;span&gt;&lt;span&gt;).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The rub is that &lt;code&gt;sendfile(2)&lt;&#x2F;code&gt; is a naive way to transfer bytes. It doesn&#x27;t know about TLS encryption. Bytes are ferried from one file descriptor to the other (maybe a socket) as-is.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ktls&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#ktls&quot; aria-label=&quot;Anchor link for: ktls&quot;&gt;kTLS&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Enter kTLS: &lt;em&gt;kernel&lt;&#x2F;em&gt; TLS. After performing a TLS handshake in userspace (your program) you can &lt;em&gt;offload&lt;&#x2F;em&gt; the work of doing TLS encryption and decryption to the kernel by setting options on the socket with the connection&#x27;s current TLS parameters. This makes things simpler in your userspace program: you don&#x27;t need to encrypt anything, just send plain text on the socket. The kernel then transparently takes care of everything.&lt;&#x2F;p&gt;
&lt;p&gt;The really special thing about kTLS, for our purposes, is that it lets us treat a TLS encrypted network connection like a regular old unencrypted socket.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ktls-sendfile-2-uploads&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#ktls-sendfile-2-uploads&quot; aria-label=&quot;Anchor link for: ktls-sendfile-2-uploads&quot;&gt;kTLS + sendfile(2) uploads&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The gist of the code using kTLS in Erlang would be:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;erlang&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-erlang &quot;&gt;&lt;code class=&quot;language-erlang&quot; data-lang=&quot;erlang&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;upload&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;File&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;%% Same as before: make a TLS handshake in userspace.
&lt;&#x2F;span&gt;&lt;span&gt;    {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;ok&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;SslSocket&lt;&#x2F;span&gt;&lt;span&gt;} = ssl:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;connect&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;s3.us-east-2.amazonaws.com&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;443&lt;&#x2F;span&gt;&lt;span&gt;, [{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ktls&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;}]),
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;%% Then handover TLS responsibilities to the kernel.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Socket &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;do_ktls_handover&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;SslSocket&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;%% Now our socket is a regular old TCP socket! Unencrypted
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;%% as far as we know!
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;ok &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;gen_tcp&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;send&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Socket&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;header&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;File&lt;&#x2F;span&gt;&lt;span&gt;)),
&lt;&#x2F;span&gt;&lt;span&gt;    {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;ok&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_BytesWritten&lt;&#x2F;span&gt;&lt;span&gt;} = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;file&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sendfile&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;File&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Socket&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;gen_tcp&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;close&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Socket&lt;&#x2F;span&gt;&lt;span&gt;).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I&#x27;m glossing over the details of the kTLS handover here intentionally. It&#x27;s not well supported by Erlang yet and I even needed to patch Erlang to support the cipher currently negotiated by the S3 servers. For a full example see &lt;a href=&quot;https:&#x2F;&#x2F;gist.github.com&#x2F;the-mikedavis&#x2F;ceb1a246cdb03cb508bdf90382b6e162&quot;&gt;this gist&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;is-it-faster&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#is-it-faster&quot; aria-label=&quot;Anchor link for: is-it-faster&quot;&gt;Is it faster?&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;No! Actually I see the userspace and kernel versions of these uploads taking a very similar amount of time on the same size file (around 500 MiB). The optimization of &lt;code&gt;sendfile(2)&lt;&#x2F;code&gt; is not speed so much as memory. We avoid reading the file at all and instead let the kernel do it. So we need fancier system-wide benchmarks rather than a simple &quot;upload time.&quot; In fact we can&#x27;t even realize the full gains of this method without specialized hardware. (More below...)&lt;&#x2F;p&gt;
&lt;p&gt;But to quote Joe Armstrong in &lt;em&gt;Erlang and OTP in Action&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Make it work, then make it beautiful, then if you really, really have to, make it fast. 90 percent of the time, if you make it beautiful, it will already be fast. So really, just make it beautiful!&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;We&#x27;ve completely avoided TLS encryption and file reads in the userspace, and I think that&#x27;s beautiful. I&#x27;m sure it&#x27;s also performant in a loaded system, but I&#x27;ll need to revisit this post with numbers when I can actually measure it.&lt;&#x2F;p&gt;
&lt;p&gt;In the meantime, we can talk about making it more beautiful.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hardware-offload&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hardware-offload&quot; aria-label=&quot;Anchor link for: hardware-offload&quot;&gt;Hardware offload&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The Linux kernel docs discuss a really juicy optimization: &lt;a href=&quot;https:&#x2F;&#x2F;docs.kernel.org&#x2F;networking&#x2F;tls.html#tls-tx-zerocopy-ro&quot;&gt;zero-copy sendfile&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;When kTLS is enabled, the encryption does not necessarily need to be done by the kernel itself. Instead, the kernel might pawn off job of encrypting data to the Network Interface Controller (NIC, also known as &quot;network card&quot;), if the NIC has the hardware-level support for doing the encryption itself. This means that instead of the encryption being done by your CPU on your RAM, the NIC takes care of everything. This lets the kernel treat the call to &lt;code&gt;sendfile(2)&lt;&#x2F;code&gt; as if it were a &lt;code&gt;sendfile(2)&lt;&#x2F;code&gt; call against a regular, unencrypted TCP socket. The kernel can send the bytes without any extra buffering for encryption.&lt;&#x2F;p&gt;
&lt;p&gt;The are some limitations to this approach: namely that the file can&#x27;t be modified between the beginning and end of &lt;code&gt;sendfile(2)&lt;&#x2F;code&gt;. For cases where files are immutable once closed, though, as they might be when you upload them to S3, this is perfectly fine.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wrapping-up&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#wrapping-up&quot; aria-label=&quot;Anchor link for: wrapping-up&quot;&gt;Wrapping up&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;This was a quick look at using kTLS and &lt;code&gt;sendfile(2)&lt;&#x2F;code&gt; to upload files to S3 as efficiently as theoretically possible. I hope to revisit this post later with numbers and graphs showing how this impacts an actual system.&lt;&#x2F;p&gt;
&lt;p&gt;In the meantime here are a bunch of links for further reading:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;erlangforums.com&#x2F;t&#x2F;introduce-kernel-tls-in-ssl-application&#x2F;952&quot;&gt;https:&#x2F;&#x2F;erlangforums.com&#x2F;t&#x2F;introduce-kernel-tls-in-ssl-application&#x2F;952&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;erlang&#x2F;otp&#x2F;pull&#x2F;6104&quot;&gt;https:&#x2F;&#x2F;github.com&#x2F;erlang&#x2F;otp&#x2F;pull&#x2F;6104&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;delthas.fr&#x2F;blog&#x2F;2023&#x2F;kernel-tls&#x2F;&quot;&gt;https:&#x2F;&#x2F;delthas.fr&#x2F;blog&#x2F;2023&#x2F;kernel-tls&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;netdevconf.org&#x2F;1.2&#x2F;papers&#x2F;ktls.pdf&quot;&gt;https:&#x2F;&#x2F;netdevconf.org&#x2F;1.2&#x2F;papers&#x2F;ktls.pdf&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;netdevconf.info&#x2F;&#x2F;0x14&#x2F;pub&#x2F;slides&#x2F;25&#x2F;TLS%20Perf%20Characterization%20slides%20-%20Netdev%200x14%20v2.pdf&quot;&gt;https:&#x2F;&#x2F;netdevconf.info&#x2F;&#x2F;0x14&#x2F;pub&#x2F;slides&#x2F;25&#x2F;TLS%20Perf%20Characterization%20slides%20-%20Netdev%200x14%20v2.pdf&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Sparse arrays in Rust and creating custom DSTs</title>
        <published>2025-07-04T00:00:00+00:00</published>
        <updated>2025-07-04T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://the-mikedavis.github.io/posts/sparse-array-dst/"/>
        <id>https://the-mikedavis.github.io/posts/sparse-array-dst/</id>
        
        <content type="html" xml:base="https://the-mikedavis.github.io/posts/sparse-array-dst/">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;dynamically-sized-types.html&quot;&gt;Dynamically sized types&lt;&#x2F;a&gt; (DSTs) are one of a few &lt;em&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;exotic-sizes.html&quot;&gt;exotically sized&lt;&#x2F;a&gt;&lt;&#x2F;em&gt; Rust types. Rust and its standard library have good tools for creating regular sized types but creating dynamically sized types can be a pain.&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ll jump through DSTs quickly and look at an application - &lt;em&gt;sparse arrays&lt;&#x2F;em&gt; - to see how tricky DSTs are today.&lt;&#x2F;p&gt;
&lt;p&gt;While creating a DST I was surprised at the lack of resources on DST creation and use. This post is meant as a reference for anyone retracing my steps, or as an informative look into a trickier part of data structure implementation in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;This post is meant for those interested in data structure design in Rust and, to get the most out of this post, you should already be familiar with the concept of a DST. Otherwise this post may be a bit in-the-weeds - but hopefully still valuable.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dynamically-sized-types&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#dynamically-sized-types&quot; aria-label=&quot;Anchor link for: dynamically-sized-types&quot;&gt;Dynamically sized types&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;DSTs are special because the compiler doesn&#x27;t know how large they are at runtime. Take a regular &lt;em&gt;sized&lt;&#x2F;em&gt; type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Color {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;red&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;green&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;blue&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler knows the size of this type. It&#x27;s the sum of it&#x27;s fields, 3 bytes.&lt;&#x2F;p&gt;
&lt;p&gt;What about &lt;code&gt;[u8]&lt;&#x2F;code&gt; though, how many bytes are in that? If it&#x27;s not a constant-sized array like &lt;code&gt;[u8; 3]&lt;&#x2F;code&gt; then you don&#x27;t know at compile-time.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dsts-in-the-wild&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#dsts-in-the-wild&quot; aria-label=&quot;Anchor link for: dsts-in-the-wild&quot;&gt;DSTs in the wild&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The two common types of DSTs you may have seen are &lt;code&gt;str&lt;&#x2F;code&gt; and &lt;code&gt;[T]&lt;&#x2F;code&gt;. In fact &lt;code&gt;str&lt;&#x2F;code&gt; is just &lt;code&gt;[u8]&lt;&#x2F;code&gt; that&#x27;s guaranteed to be UTF-8 so let&#x27;s just say &lt;code&gt;[T]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Unlike &lt;code&gt;[T; 5]&lt;&#x2F;code&gt;, &lt;code&gt;[T]&lt;&#x2F;code&gt; has an unknown number of &lt;code&gt;T&lt;&#x2F;code&gt;s. In practice you&#x27;ve probably seen this type borrowed: &lt;code&gt;&amp;amp;[T]&lt;&#x2F;code&gt;. There are also owned versions: &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;&#x2F;code&gt;, &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;&#x2F;code&gt;, &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;&#x2F;code&gt; and similar.&lt;&#x2F;p&gt;
&lt;p&gt;The borrowed version is intuitive: you have a reference to some consecutive elements in an array allocation. A &lt;code&gt;&amp;amp;[T]&lt;&#x2F;code&gt; is a slice of some number of elements of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; (or similar array allocation). And a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; is a slice of some valid UTF-8 bytes of a &lt;code&gt;String&lt;&#x2F;code&gt; (&lt;code&gt;String&lt;&#x2F;code&gt; is just a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt; that is valid UTF-8).&lt;&#x2F;p&gt;
&lt;p&gt;The owned ones are not much different. They&#x27;re really just owned: the data is on the heap and the type represents a pointer to it which has ownership of the allocated data. The trick, though, is that these types are &lt;em&gt;wider&lt;&#x2F;em&gt; than usual:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; NOTE: doesn&amp;#39;t matter what type `T` is.
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!(size_of::&amp;lt;Box&amp;lt;[T]&amp;gt;&amp;gt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;* size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;());
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Same with the borrowed kind
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!(size_of::&amp;lt;&amp;amp;[T]&amp;gt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;* size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;());
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If it were just a pointer it would be the same size as a &lt;code&gt;usize&lt;&#x2F;code&gt;: a machine word, the size of a pointer by definition. Instead &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;&#x2F;code&gt; and friends take two words to represent. One word is the pointer to the data and the other is the length of the slice.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;an-application-sparse-arrays&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#an-application-sparse-arrays&quot; aria-label=&quot;Anchor link for: an-application-sparse-arrays&quot;&gt;An application: sparse arrays&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;I&#x27;ll be talking about sparse arrays as they are used in the use-case I&#x27;m interested in: &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hash_array_mapped_trie&quot;&gt;Hash Array Mapped Trie&lt;&#x2F;a&gt;s. In this context, a sparse array is an array - a contiguous sequence of values - where you expect a &quot;sparse&quot; number (i.e. few) entries to actually be used. The rest of the slots are left uninitialized or as defaults.&lt;&#x2F;p&gt;
&lt;p&gt;If you&#x27;re familiar with &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;, a sparse array is conceptually like &lt;code&gt;[MaybeUninit&amp;lt;T&amp;gt;; N]&lt;&#x2F;code&gt;. The upside of sparse arrays is that you don&#x27;t pay the cost of representing uninitialized slots.&lt;&#x2F;p&gt;
&lt;p&gt;Say you have a &lt;code&gt;[T; 64]&lt;&#x2F;code&gt; - 64 &lt;code&gt;T&lt;&#x2F;code&gt;s, stored contiguously in memory. If only some of these are initialized or meaningful then you waste a lot of space representing the entire array. Only utilizing some small &lt;code&gt;N&lt;&#x2F;code&gt; indices of this array leaves &lt;code&gt;64 - N&lt;&#x2F;code&gt; slots wasted. When you have very many of these arrays or when &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;&#x2F;code&gt; is large, wasted &lt;code&gt;T&lt;&#x2F;code&gt; allocations can add up.&lt;&#x2F;p&gt;
&lt;p&gt;Sparse arrays cut down on this wasted space by only allocating enough space to store occupied slots. Then a header is used to determine which indexes into the array are occupied by which slots. For Hash Array Mapped Tries, the layout looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;derive&lt;&#x2F;span&gt;&lt;span&gt;(Clone, Copy, PartialEq, Eq)]
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;repr&lt;&#x2F;span&gt;&lt;span&gt;(transparent)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Bitmap(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;repr&lt;&#x2F;span&gt;&lt;span&gt;(C)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;SparseArray&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bitmap&lt;&#x2F;span&gt;&lt;span&gt;: Bitmap,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;entries&lt;&#x2F;span&gt;&lt;span&gt;: [T],
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;At the beginning of this type, a 64-bit bitmap describes which entries are set in the dynamically sized array, and which indexes into the &lt;code&gt;SparseArray&lt;&#x2F;code&gt; correspond to which index in &lt;code&gt;entries&lt;&#x2F;code&gt;. With this layout, setting index &lt;code&gt;5&lt;&#x2F;code&gt; to &lt;code&gt;100&lt;&#x2F;code&gt; and &lt;code&gt;10&lt;&#x2F;code&gt; to &lt;code&gt;200&lt;&#x2F;code&gt; means that the 5th and 10th bit of the bitmap are set and the entries array is allocated with &lt;code&gt;100&lt;&#x2F;code&gt; and then &lt;code&gt;200&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;You can imagine an empty sparse array as just the bitmap:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;+------+
&lt;&#x2F;span&gt;&lt;span&gt;+ 0000 +
&lt;&#x2F;span&gt;&lt;span&gt;+------+
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And then a sparse array with elements at index 0 and 3 could be:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;+------+------+------+
&lt;&#x2F;span&gt;&lt;span&gt;+ 1001 +  T   +  T   +
&lt;&#x2F;span&gt;&lt;span&gt;+------+------+------+
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This use-case fits a dynamically sized type well: the true size of the type depends on its value at runtime. The number of bits set in the bitmap is the number of entries in &lt;code&gt;entries&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This takes a fixed size of overhead for every sparse array, but you don&#x27;t pay for allocating uninitialized or meaningless entries.&lt;&#x2F;p&gt;
&lt;p&gt;This post skips over the implications of inserting or deleting an element (resizing the sparse array) and other interesting features. I will cover Hash Array Mapped Tries in part two of this post. Instead here we&#x27;ll talk about how implementing this type - and using it - is a pain, and how we can make our lives easier by just giving up and dealing with pointers.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fighting-for-a-dst-a-fool-s-errand&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fighting-for-a-dst-a-fool-s-errand&quot; aria-label=&quot;Anchor link for: fighting-for-a-dst-a-fool-s-errand&quot;&gt;Fighting for a DST - a fool&#x27;s errand&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;My first implementation of this type looked just like the above &lt;code&gt;SparseArray&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;repr&lt;&#x2F;span&gt;&lt;span&gt;(C)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;SparseArray&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bitmap&lt;&#x2F;span&gt;&lt;span&gt;: Bitmap,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;entries&lt;&#x2F;span&gt;&lt;span&gt;: [T],
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that &lt;code&gt;entries: [T]&lt;&#x2F;code&gt; is what makes it a DST and will bring us much pain. (As a peculiarity of custom DSTs, it must be the last field which is a DST. A DST anywhere else is an error.) The compiler can see from &lt;code&gt;[T]&lt;&#x2F;code&gt; that we&#x27;re dealing with an &quot;unsized&quot; type (&lt;code&gt;?Sized&lt;&#x2F;code&gt;) and will let us know in future error messages.&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ll start with making an empty &lt;code&gt;SparseArray&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Bitmap {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; No bits set means no entries.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;EMPTY&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; SparseArray&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;empty&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{ bitmap: Bitmap::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;EMPTY&lt;&#x2F;span&gt;&lt;span&gt;, entries: [] }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But already we run into trouble:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0277]: the size for values of type `[T]` cannot be known at compilation time
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;lib.rs:15:23
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;15 |     pub fn empty() -&amp;gt; Self {
&lt;&#x2F;span&gt;&lt;span&gt;   |                       ^^^^ doesn&amp;#39;t have a size known at compile-time
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;   = help: within `SparseArray&amp;lt;T&amp;gt;`, the trait `Sized` is not implemented for `[T]`
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The gist is that we can&#x27;t return &lt;code&gt;SparseArray&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; from any function. This is the same for familiar DSTs too: you can&#x27;t have a variable bound to some &lt;code&gt;[T]&lt;&#x2F;code&gt;. Instead you always work in terms of &lt;code&gt;&amp;amp;[T]&lt;&#x2F;code&gt; or &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;&#x2F;code&gt; (or similar owned wrapper).&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ðŸ’£  &amp;amp;[T] is ok but not [T]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;count&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;arr&lt;&#x2F;span&gt;&lt;span&gt;: [T]) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    arr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;count&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0277]: the size for values of type `[T]` cannot be known at compilation time
&lt;&#x2F;span&gt;&lt;span&gt; --&amp;gt; src&#x2F;lib.rs:1:16
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;1 | fn count&amp;lt;T&amp;gt;(arr: [T]) -&amp;gt; usize {
&lt;&#x2F;span&gt;&lt;span&gt;  |                ^^^ doesn&amp;#39;t have a size known at compile-time
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;  = help: the trait `Sized` is not implemented for `[T]`
&lt;&#x2F;span&gt;&lt;span&gt;help: function arguments must have a statically known size, borrowed slices always have a known size
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;1 | fn count&amp;lt;T&amp;gt;(arr: &amp;amp;[T]) -&amp;gt; usize {
&lt;&#x2F;span&gt;&lt;span&gt;  |   
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A consequence of being unable to return &lt;code&gt;Self&lt;&#x2F;code&gt; is that we can&#x27;t implement useful traits like &lt;code&gt;Clone&lt;&#x2F;code&gt; and &lt;code&gt;Default&lt;&#x2F;code&gt;. So already we are drifting away from the the nice tools available for sized types.&lt;&#x2F;p&gt;
&lt;p&gt;The solution here? Return an owned type wrapping &lt;code&gt;SparseArray&lt;&#x2F;code&gt;. Like mentioned above we can use a &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;&#x2F;code&gt;, &lt;code&gt;Rc&amp;lt;Self&amp;gt;&lt;&#x2F;code&gt;, &lt;code&gt;Arc&amp;lt;Self&amp;gt;&lt;&#x2F;code&gt; or anything similar. I&#x27;ll use &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;&#x2F;code&gt; here for simplicity, though eventually I want an &lt;code&gt;Arc&lt;&#x2F;code&gt; to make this data structure persistent and thread-safe.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;std::{
&lt;&#x2F;span&gt;&lt;span&gt;    alloc::{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, Layout},
&lt;&#x2F;span&gt;&lt;span&gt;    ptr::{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, NonNull},
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Bitmap {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;count_ones&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; SparseArray&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;empty&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; Box&amp;lt;SparseArray&amp;lt;T&amp;gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; bitmap = Bitmap::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;EMPTY&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; layout = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;::layout(bitmap.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; nullable = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ alloc::alloc(layout) };
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;NonNull::new(nullable) {
&lt;&#x2F;span&gt;&lt;span&gt;            Some(ptr) =&amp;gt; ptr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;            None =&amp;gt; alloc::handle_alloc_error(layout),
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; This is necessary in order to be able to cast!!
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = ptr::slice_from_raw_parts_mut(ptr, len) as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*mut Self&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ (&amp;amp;raw &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;((*ptr).bitmap)).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span&gt;(bitmap) }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; TODO: we&amp;#39;d then write entries, if there were any.
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ Box::from_raw(ptr) }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;layout&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Layout {
&lt;&#x2F;span&gt;&lt;span&gt;        Layout::new::&amp;lt;Bitmap&amp;gt;()
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;extend&lt;&#x2F;span&gt;&lt;span&gt;(Layout::array::&amp;lt;T&amp;gt;(len).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pad_to_align&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Reaching into pointer and allocation stuff from &lt;code&gt;std::alloc&lt;&#x2F;code&gt; and &lt;code&gt;std::ptr&lt;&#x2F;code&gt; may look a little ham-fisted but it&#x27;s not necessarily unusual for data structure implementations. The part of this that was unfamiliar to me was &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;ptr&#x2F;fn.slice_from_raw_parts.html&quot;&gt;&lt;code&gt;std::ptr::slice_from_raw_parts_mut&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. This is one of the standard library&#x27;s few utilities for working with dynamically sized types. The important part about this function is that it forms a possibly wide pointer based on the metadata (second argument). A &lt;em&gt;wide pointer&lt;&#x2F;em&gt; describes the pointer itself along with some metadata like the number of elements in a &lt;code&gt;[T]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;So with &lt;code&gt;empty&lt;&#x2F;code&gt; or &lt;code&gt;new&lt;&#x2F;code&gt;, &lt;code&gt;Box&amp;lt;SparseArray&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt; actually ends up as &lt;code&gt;size_of::&amp;lt;usize&amp;gt;() * 2&lt;&#x2F;code&gt;. One word holds the pointer to the DST and another holds the length of &lt;code&gt;entries&lt;&#x2F;code&gt;. Unfortunately this is using extra space to encode data that we already know. The number of entries can be computed from the bitmap by counting the number of 1 bits, either through CPU-specific instructions, a series of shifts or SIMD.&lt;&#x2F;p&gt;
&lt;p&gt;Already I don&#x27;t like adding unnecessary data just to track the DST. And as mentioned above, we&#x27;re fighting common traits. If we try to reimplement &lt;code&gt;Clone&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: Clone&amp;gt; SparseArray&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Box&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; TODO: `new` is like `empty` but writes the `entries` too
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; based on the iterator
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;::new(this.bitmap, this.entries.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;cloned&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This doesn&#x27;t look very much like a regular &lt;code&gt;impl Clone for T&lt;&#x2F;code&gt;. And to call it we need to use &lt;code&gt;SparseArray::clone(&amp;amp;my_sparse_array)&lt;&#x2F;code&gt; :&#x2F;. We&#x27;ve left familiar Rust ergonomics!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-workaround-pointers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-workaround-pointers&quot; aria-label=&quot;Anchor link for: the-workaround-pointers&quot;&gt;The workaround: pointers&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;We&#x27;re straying from the niceties of sized types and that leaves us doing un-ergonomic stuff. Can we make things simpler for ourselves, and maybe avoid that extra wide-pointer overhead, please?&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-type&quot; aria-label=&quot;Anchor link for: the-type&quot;&gt;The type&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;entries: [T]&lt;&#x2F;code&gt; is a problem because it&#x27;s a DST. Let&#x27;s replace it with a sized type... &lt;code&gt;[T; 0]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Bitmap {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;MAX_ENTRIES&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;BITS
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;repr&lt;&#x2F;span&gt;&lt;span&gt;(C)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;SparseArrayInner&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bitmap&lt;&#x2F;span&gt;&lt;span&gt;: Bitmap,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; HEY! This location is a sequence of `0..Bitmap::MAX_ENTRIES`
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; `T`s. `read`&#x2F;`write` it accordingly!!
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;entries&lt;&#x2F;span&gt;&lt;span&gt;: [T; 0],
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;SparseArray&amp;lt;T&amp;gt;(NonNull&amp;lt;SparseArrayInner&amp;lt;T&amp;gt;&amp;gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now &lt;code&gt;SparseArray&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; is a pointer to some allocated type and we&#x27;ve chosen to hide the actual size of &lt;code&gt;SparseArrayInner&lt;&#x2F;code&gt; from the compiler. The tradeoff is that we are now responsible for allocating the data and accessing it appropriately. And now &lt;code&gt;SparseArray&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; is a sized type: &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; is a pointer and we know the size of a pointer statically.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;accessing-the-bitmap-and-entries&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#accessing-the-bitmap-and-entries&quot; aria-label=&quot;Anchor link for: accessing-the-bitmap-and-entries&quot;&gt;Accessing the bitmap and entries&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;If the &lt;code&gt;SparseArray&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; type is a pointer to the inner type, we can read that pointer to get the &lt;code&gt;Bitmap&lt;&#x2F;code&gt; and &lt;code&gt;&amp;amp;[T]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; SparseArray&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;bitmap&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Bitmap {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span&gt;() }.bitmap
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;entries&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &amp;amp;[T] {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; len = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bitmap&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &amp;amp;raw &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;(*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;()).entries }.cast::&amp;lt;T&amp;gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ std::slice::from_raw_parts(ptr, len) }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In &lt;code&gt;SparseArray::entries&lt;&#x2F;code&gt; we cast the pointer to the entries, &lt;code&gt;*const [T; 0]&lt;&#x2F;code&gt;, to be a &lt;code&gt;*const T&lt;&#x2F;code&gt;. This lets us create a slice from it. The safety docs for &lt;code&gt;slice::from_raw_parts&lt;&#x2F;code&gt; say that the pointer must be valid for a read of &lt;code&gt;len&lt;&#x2F;code&gt; &lt;code&gt;T&lt;&#x2F;code&gt;s. As long as we allocate and initialize those entries then we&#x27;re good to go.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;allocating-the-sparse-array&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allocating-the-sparse-array&quot; aria-label=&quot;Anchor link for: allocating-the-sparse-array&quot;&gt;Allocating the sparse array&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Let&#x27;s rewrite &lt;code&gt;SparseArray::new&lt;&#x2F;code&gt; from above to allocate the memory, but then cast it as a &lt;code&gt;SparseArrayInner&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; rather than deal with &lt;code&gt;ptr::slice_from_raw_parts_mut&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; SparseArray&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;new&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;I: IntoIterator&amp;lt;Item = T&amp;gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bitmap&lt;&#x2F;span&gt;&lt;span&gt;: Bitmap, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;entries&lt;&#x2F;span&gt;&lt;span&gt;: I) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; len = bitmap.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; layout = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;::layout(len);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; nullable = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ alloc::alloc(layout) };
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; non_null = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;NonNull::new(nullable) {
&lt;&#x2F;span&gt;&lt;span&gt;            Some(ptr) =&amp;gt; ptr.cast::&amp;lt;SparseArrayInner&amp;lt;T&amp;gt;&amp;gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;            None =&amp;gt; alloc::handle_alloc_error(layout),
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = non_null.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ (&amp;amp;raw &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;((*ptr).bitmap)).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span&gt;(bitmap) }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; entries_ptr = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &amp;amp;raw &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;((*ptr).entries) as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*mut&lt;&#x2F;span&gt;&lt;span&gt; T };
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(i, entry) in entries.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;enumerate&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ entries_ptr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt;(i).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span&gt;(entry) };
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;(non_null)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;layout&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Layout {
&lt;&#x2F;span&gt;&lt;span&gt;        Layout::new::&amp;lt;Bitmap&amp;gt;()
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;extend&lt;&#x2F;span&gt;&lt;span&gt;(Layout::array::&amp;lt;T&amp;gt;(len).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pad_to_align&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We allocate for enough &lt;code&gt;T&lt;&#x2F;code&gt;s according to the &lt;code&gt;Bitmap::len&lt;&#x2F;code&gt;. Then, like above, we cast the pointer to the entries, &lt;code&gt;*mut [T; 0]&lt;&#x2F;code&gt;, to &lt;code&gt;*mut T&lt;&#x2F;code&gt; and then perform the writing of contiguous entries ourselves.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;default&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#default&quot; aria-label=&quot;Anchor link for: default&quot;&gt;&lt;code&gt;Default&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Now that &lt;code&gt;SparseArray&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; is a sized type, we can create them ergonomically with familiar traits like &lt;code&gt;Default&lt;&#x2F;code&gt;. This replaces our prior &lt;code&gt;SparseArray::empty&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; Default &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;SparseArray&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;default&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;::new(Bitmap::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;EMPTY&lt;&#x2F;span&gt;&lt;span&gt;, [])
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That&#x27;s more like it! Very straightforward.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;clone&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#clone&quot; aria-label=&quot;Anchor link for: clone&quot;&gt;&lt;code&gt;Clone&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;While we&#x27;re at it, implementing &lt;code&gt;Clone&lt;&#x2F;code&gt; is straightforward too: copy the bitmap and clone all of the entries.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: Clone&amp;gt; Clone &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;SparseArray&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bitmap&lt;&#x2F;span&gt;&lt;span&gt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;entries&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;cloned&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As mentioned above I want to use this type in a Hash Array Mapped Trie and I want to put the pointer behind an &lt;code&gt;Arc&lt;&#x2F;code&gt;. &lt;code&gt;Clone&lt;&#x2F;code&gt; is a really useful standard trait to implement for this use-case since it will allow us to use the awesome standard library function &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;sync&#x2F;struct.Arc.html#method.make_mut&quot;&gt;&lt;code&gt;Arc::make_mut&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; which makes concurrent persistent data structures easy to implement.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;drop&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#drop&quot; aria-label=&quot;Anchor link for: drop&quot;&gt;&lt;code&gt;Drop&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;The really important trait to implement is &lt;code&gt;Drop&lt;&#x2F;code&gt;. Since we&#x27;ve taken over the allocation of this type, the compiler will no longer help us drop it correctly.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; Drop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;SparseArray&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;drop&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;std::mem::needs_drop::&amp;lt;T&amp;gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; NOTE: `entries_mut` is mostly the same as `entries`
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; but uses `from_raw_parts_mut` instead.
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; entry in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;entries_mut&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = entry as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*mut &lt;&#x2F;span&gt;&lt;span&gt;_;
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ ptr::drop_in_place(ptr) };
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; layout = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;::layout(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bitmap&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ alloc::dealloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.ptr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;cast&lt;&#x2F;span&gt;&lt;span&gt;(), layout) }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When dropping a &lt;code&gt;SparseArray&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; we first drop the entries, if they need to be dropped, and then deallocate the chunk of memory.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wrapping-up&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#wrapping-up&quot; aria-label=&quot;Anchor link for: wrapping-up&quot;&gt;Wrapping up&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;With the new definition of &lt;code&gt;SparseArray&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; we have a sized type which can implement common traits like &lt;code&gt;Default&lt;&#x2F;code&gt; and &lt;code&gt;Clone&lt;&#x2F;code&gt;. While the actual allocated chunk of memory has a variable size, the size of a &lt;code&gt;SparseArray&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; is constant and &lt;em&gt;thin&lt;&#x2F;em&gt; - only the size of a pointer. Now we don&#x27;t waste an extra &lt;code&gt;usize&lt;&#x2F;code&gt; of memory on tracking the &lt;code&gt;entries&lt;&#x2F;code&gt; length twice.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;assert_eq!(size_of::&amp;lt;SparseArray&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;(), size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;());
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; The size of the inner type doesn&amp;#39;t matter!
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!(size_of::&amp;lt;SparseArray&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u128&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;(), size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;());
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;While custom sized types are well supported by the standard library, dynamically sized types (DSTs) can be annoying to create and work with. An escape hatch for this is to put the type behind a pointer yourself. This places more responsibility on you, but it gives you full control over the type&#x27;s representation.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>&quot;German string&quot; optimizations in Spellbook</title>
        <published>2024-11-03T00:00:00+00:00</published>
        <updated>2024-11-03T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://the-mikedavis.github.io/posts/german-string-optimizations-in-spellbook/"/>
        <id>https://the-mikedavis.github.io/posts/german-string-optimizations-in-spellbook/</id>
        
        <content type="html" xml:base="https://the-mikedavis.github.io/posts/german-string-optimizations-in-spellbook/">&lt;h1 id=&quot;spellbook&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#spellbook&quot; aria-label=&quot;Anchor link for: spellbook&quot;&gt;Spellbook&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;helix-editor&#x2F;spellbook&quot;&gt;Spellbook&lt;&#x2F;a&gt; is a Rust spell-checking library I&#x27;ve written the style of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;hunspell&#x2F;hunspell&quot;&gt;Hunspell&lt;&#x2F;a&gt; to bring spell checking to the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;helix-editor&#x2F;helix&quot;&gt;Helix editor&lt;&#x2F;a&gt;. It&#x27;s more-or-less a Rust rewrite of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nuspell&#x2F;nuspell&quot;&gt;Nuspell&lt;&#x2F;a&gt;, which itself is more-or-less a rewrite of Hunspell. Spellbook has a pretty slim interface: you can instantiate a dictionary from Hunspell dictionary files and use it to check words. For a small example of how you might use Spellbook:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Dictionary files can be sourced from
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; &amp;lt;https:&#x2F;&#x2F;github.com&#x2F;LibreOffice&#x2F;dictionaries&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; aff = std::fs::read_to_string(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;en_US.aff&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; dic = std::fs::read_to_string(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;en_US.dic&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; dict = spellbook::Dictionary::new(&amp;amp;aff, &amp;amp;dic).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; word = std::env::args().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;nth&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;expect&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;expected a word to check&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; dict.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;check&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;word) {
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{word:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; is in the dictionary.&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{word:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; is NOT in the dictionary.&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;        std::process::exit(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this post we&#x27;ll be looking at the string representation used in Spellbook and aiming to optimize it to save memory.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;strings-in-spellbook&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#strings-in-spellbook&quot; aria-label=&quot;Anchor link for: strings-in-spellbook&quot;&gt;Strings in Spellbook&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;How Spellbook works exactly is beyond the scope of this post, so this section gives a simplified overview and deals with simplified types. If you&#x27;re interested in more details, check out the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;helix-editor&#x2F;spellbook&#x2F;blob&#x2F;master&#x2F;README.md#how-does-it-work&quot;&gt;Spellbook README&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;zverok.space&#x2F;spellchecker.html&quot;&gt;@zverok&#x27;s Rebuilding the Spellchecker&lt;&#x2F;a&gt; blog post and the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;helix-editor&#x2F;spellbook&#x2F;blob&#x2F;master&#x2F;docs&#x2F;internals.md&quot;&gt;Spellbook internals document&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;A central part of the procedure to check a word is to look up word(s) in a hash table. This lookup table contains an entry for each &quot;stem&quot; in the dictionary. You might imagine that the &lt;code&gt;Dictionary&lt;&#x2F;code&gt; type is a wrapper around a &lt;code&gt;HashSet&amp;lt;String&amp;gt;&lt;&#x2F;code&gt;. This is correct in essence but Hunspell-like checkers don&#x27;t store every possible word in memory. Instead there is some &quot;compression.&quot; For an example from the &lt;code&gt;en_US&lt;&#x2F;code&gt; (American English) dictionary, the lookup table in Spellbook associates a stem &quot;adventure&quot; with a set of flags like &#x27;D&#x27;, &#x27;R&#x27; and &#x27;S&#x27;. The flags correspond to rules defined for the dictionary allowing transformations like prefixes and suffixes. &#x27;D&#x27; for example allows adding the &quot;d&quot; (or &quot;ed&quot; or &quot;ied&quot;, depending on the stem) suffix, producing &quot;adventured.&quot; &#x27;R&#x27; allows &quot;adventurer&quot; and &#x27;S&#x27; allows &quot;adventures.&quot; So we can imagine that the lookup table has a type similar to &lt;code&gt;HashMap&amp;lt;String, HashSet&amp;lt;Flag&amp;gt;&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Despite the &quot;compression&quot; that prefixes and suffixes enable, the lookup table contains many entries. The exact number varies with which dictionary files you use as input but American English contains around 50,000 stems, and it&#x27;s a relatively slim dictionary. Others contain hundreds of thousands or even millions of stems, so it&#x27;s worth trying to optimize the space we take for each stem.&lt;&#x2F;p&gt;
&lt;p&gt;Good optimizations come from good observations so let&#x27;s list out some properties of these strings:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Once inserted into the lookup table these strings are never modified.&lt;&#x2F;li&gt;
&lt;li&gt;These strings have a small maximum size. Spellbook refuses to check words over 360 bytes long (in UTF-8 representation) so there&#x27;s no point in storing words over 360 bytes in the lookup table.&lt;&#x2F;li&gt;
&lt;li&gt;Stems correspond to words so they&#x27;re typically shorter rather than longer.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;strings-in-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#strings-in-rust&quot; aria-label=&quot;Anchor link for: strings-in-rust&quot;&gt;Strings in Rust&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;Let&#x27;s take a bit of a detour to talk about how strings are represented in Rust. For starters there&#x27;s the &lt;code&gt;String&lt;&#x2F;code&gt; type. &lt;code&gt;String&lt;&#x2F;code&gt;s are quite flexible: they can be modified, resized and have a large maximum size. As for how they are represented, the Rust docs say:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;code&gt;String&lt;&#x2F;code&gt; is made up of three components: a pointer to some bytes, a length, and a capacity.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Simplifying a bit here, we can imagine a String looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;String {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pointer&lt;&#x2F;span&gt;&lt;span&gt;: NonNull&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;length&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;capacity&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;box-str-and-fat-pointers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#box-str-and-fat-pointers&quot; aria-label=&quot;Anchor link for: box-str-and-fat-pointers&quot;&gt;&lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; and fat pointers&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;The first thing that comes to mind is that storing &lt;code&gt;length&lt;&#x2F;code&gt; and &lt;code&gt;capacity&lt;&#x2F;code&gt; is redundant for our use-case. In our lookup table the strings are never modified so there&#x27;s no need to store any extra information that would allow us to resize the string. A non-resizable string can be written with the &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; type. &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; is the owned version of a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; and slices (&lt;code&gt;&amp;amp;[T]&lt;&#x2F;code&gt;) have an interesting representation and learning about them is a good way to dig into &quot;fat pointers&quot; in Rust. A &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; (or equivalently, &lt;code&gt;&amp;amp;[u8]&lt;&#x2F;code&gt;) is a fat pointer - a pointer to some bytes plus some metadata. For &lt;code&gt;&amp;amp;[T]&lt;&#x2F;code&gt; the metadata is the length of the slice. Using a fat pointer makes string (&lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;) and other slices nice to work with - you can subslice and read the length of a string slice cheaply and ergonomically. &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; and &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;&#x2F;code&gt; are laid out the same way.&lt;&#x2F;p&gt;
&lt;p&gt;You can imagine that these fat pointers are basically a tuple &lt;code&gt;(*const T, usize)&lt;&#x2F;code&gt;. This takes 2 &lt;code&gt;usize&lt;&#x2F;code&gt;s worth of memory to represent: one &lt;code&gt;usize&lt;&#x2F;code&gt; for the actual pointer (&quot;thin pointer&quot;) and one for the metadata. What exactly is a &lt;code&gt;usize&lt;&#x2F;code&gt; though? Quoting the Rust docs again:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The size of [&lt;code&gt;usize&lt;&#x2F;code&gt;] is how many bytes it takes to reference any location in memory. For example, on a 32 bit target, this is 4 bytes and on a 64 bit target, this is 8 bytes.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;So &lt;code&gt;usize&lt;&#x2F;code&gt; is an unsigned integer type of the same size as a &quot;thin pointer&quot;: a pointer with no metadata, like &lt;code&gt;*const T&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;*mut T&lt;&#x2F;code&gt; or equivalently &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;. For simplicity we&#x27;ll talk only about 64 bit targets for the rest of the post and assume that &lt;code&gt;size_of::&amp;lt;usize&amp;gt;() == 8&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;By switching the stem type to &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; we save 8 bytes per stem from not tracking &lt;code&gt;capacity&lt;&#x2F;code&gt;, taking advantage of our observation that strings are not modified. Nice! But there&#x27;s still room for improvement from our other observations.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;the-road-to-german-strings&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-road-to-german-strings&quot; aria-label=&quot;Anchor link for: the-road-to-german-strings&quot;&gt;The road to &quot;German strings&quot;&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;The other observations are about the length of each string. They&#x27;re short. If the &lt;code&gt;length&lt;&#x2F;code&gt; field is a &lt;code&gt;usize&lt;&#x2F;code&gt; that means your strings can be at most 2^64 bytes long, and &lt;em&gt;wow that is long&lt;&#x2F;em&gt;! Our strings will never be longer than 360 bytes so of the 64 bits we use to represent the length we&#x27;ll only ever use 9 (2^9 = 512). That&#x27;s quite a few bits wasted. If we used a &lt;code&gt;u16&lt;&#x2F;code&gt; to store the length instead we&#x27;d save 6 bytes. What should we do with those 6 bytes we&#x27;ve saved?&lt;&#x2F;p&gt;
&lt;p&gt;This is where &quot;German strings&quot; come in. &quot;German strings&quot; or &quot;German-style strings&quot; or &quot;Umbra strings&quot; (all the same thing) are described very well in a post from CedarDB: &lt;a href=&quot;https:&#x2F;&#x2F;cedardb.com&#x2F;blog&#x2F;german_strings&#x2F;&quot;&gt;Why German Strings are Everywhere&lt;&#x2F;a&gt;. The idea is to use a integer type smaller than &lt;code&gt;usize&lt;&#x2F;code&gt; for the length (&lt;code&gt;u32&lt;&#x2F;code&gt; in their case) and repurpose the remaining bytes to store a prefix of the data. We can store a few more bytes in the &quot;prefix&quot; section since we&#x27;re using a &lt;code&gt;u16&lt;&#x2F;code&gt; for length, so our type would look like this in memory:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;repr&lt;&#x2F;span&gt;&lt;span&gt;(C)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;UmbraString {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; takes 2 bytes
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prefix&lt;&#x2F;span&gt;&lt;span&gt;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;; 6], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; takes 6 bytes
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pointer&lt;&#x2F;span&gt;&lt;span&gt;: NonNull&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; this takes `usize` (8 bytes)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;+-------+-----------------------+-------------------------------+
&lt;&#x2F;span&gt;&lt;span&gt;+  len  +        prefix         +           pointer             +
&lt;&#x2F;span&gt;&lt;span&gt;+-------+-----------------------+-------------------------------+
&lt;&#x2F;span&gt;&lt;span&gt;   u16           6x u8                       8x u8
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Umbra and CedarDB like this prefix because it can be used to cheaply compute whether two of these &lt;code&gt;UmbraString&lt;&#x2F;code&gt;s are (not) equal - the &lt;code&gt;Eq&lt;&#x2F;code&gt; trait in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;Consider a very short string like &quot;hi!&quot;. In memory that would look like so:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;+-------+-----------------------+-------------------------------+
&lt;&#x2F;span&gt;&lt;span&gt;+ 3u16  + h   i   !   .   .   . +         pointer (?)           +
&lt;&#x2F;span&gt;&lt;span&gt;+-------+-----------------------+-------------------------------+
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And what&#x27;s the pointer pointing to? Nothing I guess. We already stored the full string right in the struct &quot;inline.&quot; So there&#x27;s no need to allocate memory and point to it.&lt;&#x2F;p&gt;
&lt;p&gt;In fact for medium-long strings that can fit in the prefix bytes plus the pointer bytes, we can eliminate the pointer part altogether. This is a &lt;strong&gt;S&lt;&#x2F;strong&gt;hort &lt;strong&gt;S&lt;&#x2F;strong&gt;tring &lt;strong&gt;O&lt;&#x2F;strong&gt;ptimization (SSO): when the string is short enough, we can store it directly in our &lt;code&gt;UmbraString&lt;&#x2F;code&gt; struct and avoid allocating a buffer. We can store 6 bytes in the prefix and another 8 in the suffix area for a total of 14 bytes inline. For an ASCII string, that&#x27;s up to 14 characters we can represent without allocating. Very nice!&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;+-------+-----------------------+-------------------------------+
&lt;&#x2F;span&gt;&lt;span&gt;+ 12u16 + h   e   l   l   o  _  + w   o   r   l   d   !   .   . +
&lt;&#x2F;span&gt;&lt;span&gt;+-------+-----------------------+-------------------------------+
&lt;&#x2F;span&gt;&lt;span&gt;   len           prefix                     suffix
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This either-or type would look like so, using a &lt;code&gt;union&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;repr&lt;&#x2F;span&gt;&lt;span&gt;(C)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;UmbraString {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prefix&lt;&#x2F;span&gt;&lt;span&gt;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;; 6],
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;trailing&lt;&#x2F;span&gt;&lt;span&gt;: Trailing
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;repr&lt;&#x2F;span&gt;&lt;span&gt;(C)]
&lt;&#x2F;span&gt;&lt;span&gt;union Trailing {
&lt;&#x2F;span&gt;&lt;span&gt;    suffix: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ManuallyDrop is necessary since we only want
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; to deallocate the buffer if we&amp;#39;re using the
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; &amp;quot;long&amp;quot; variant of this union.
&lt;&#x2F;span&gt;&lt;span&gt;    ptr: ManuallyDrop&amp;lt;NonNull&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;How do we know which member of the &lt;code&gt;union&lt;&#x2F;code&gt; our &lt;code&gt;UmbraString&lt;&#x2F;code&gt; is? Just look at the &lt;code&gt;len&lt;&#x2F;code&gt; field: if it&#x27;s 14 or less then we&#x27;re using the &quot;short&quot; variant - everything inline. If it&#x27;s 15 or greater then the string is allocated and pointed to.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;memory-savings&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#memory-savings&quot; aria-label=&quot;Anchor link for: memory-savings&quot;&gt;Memory savings&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;Why is this layout so attractive?&lt;&#x2F;p&gt;
&lt;p&gt;This representation is no more expensive than a &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; in terms of memory consumption. &lt;code&gt;size_of::&amp;lt;Box&amp;lt;str&amp;gt;&amp;gt;()&lt;&#x2F;code&gt; is &lt;code&gt;16&lt;&#x2F;code&gt; - 16 bytes. (Note that &lt;code&gt;size_of&lt;&#x2F;code&gt; is counting the size of the type, not the size of the allocation the pointer is pointing to.) &lt;code&gt;size_of::&amp;lt;UmbraString&amp;gt;()&lt;&#x2F;code&gt; is also &lt;code&gt;16&lt;&#x2F;code&gt;. The difference is that any non-empty &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; will allocate. A short string like &quot;hi!&quot; allocates 3 bytes somewhere on the heap for a total of 19 bytes. &lt;code&gt;UmbraString&lt;&#x2F;code&gt; does not: it&#x27;s still 16 bytes. For a medium string like &quot;hello_world!&quot; &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; will allocate those 12 bytes on the heap for a total cost of 28 bytes. The equivalent &lt;code&gt;UmbraString&lt;&#x2F;code&gt; is still a total of 16 bytes. For long strings like &lt;code&gt;&quot;a&quot;.repeat(50)&lt;&#x2F;code&gt;, &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; will allocate the 50 bytes for a total cost of 66 bytes. In the worst case (long strings) &lt;code&gt;UmbraString&lt;&#x2F;code&gt; &lt;strong&gt;is no worse&lt;&#x2F;strong&gt;: it also takes exactly 66 bytes.&lt;&#x2F;p&gt;
&lt;p&gt;Umbra strings are attractive here because they don&#x27;t have a memory cost: we would be paying the 16 bytes of a &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; anyways and wasting the 6 bytes from the length &lt;code&gt;usize&lt;&#x2F;code&gt;. Any time we use the inline variant of &lt;code&gt;UmbraString&lt;&#x2F;code&gt; we save memory.&lt;&#x2F;p&gt;
&lt;p&gt;You might also think &lt;code&gt;UmbraString&lt;&#x2F;code&gt; is faster to work with if you commonly have short strings because you don&#x27;t need to follow a pointer to compare data. We&#x27;ll see in the benchmarks that &lt;code&gt;UmbraString&lt;&#x2F;code&gt; is not much different in terms of speed. We need an extra comparison operation to figure out if we&#x27;re using a short or long variant after all.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;theory-into-practice-let-s-build-umbrastring&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#theory-into-practice-let-s-build-umbrastring&quot; aria-label=&quot;Anchor link for: theory-into-practice-let-s-build-umbrastring&quot;&gt;Theory into practice: let&#x27;s build &lt;code&gt;UmbraString&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;This is basically the same snippet as above. We&#x27;ll define some constants for the lengths of each segment and some basic helpers.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::mem::{size_of, ManuallyDrop};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::ptr::NonNull;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 6 on 64 bit machines
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PREFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;() - size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 8 on 64 bit machines
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SUFFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; We can fit 14 bytes inline, nice!
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;INLINE_LEN&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16 &lt;&#x2F;span&gt;&lt;span&gt;= (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PREFIX_LEN &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SUFFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;) as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;repr&lt;&#x2F;span&gt;&lt;span&gt;(C)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;UmbraString {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prefix&lt;&#x2F;span&gt;&lt;span&gt;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;; PREFIX_LEN],
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;trailing&lt;&#x2F;span&gt;&lt;span&gt;: Trailing,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;repr&lt;&#x2F;span&gt;&lt;span&gt;(C)]
&lt;&#x2F;span&gt;&lt;span&gt;union Trailing {
&lt;&#x2F;span&gt;&lt;span&gt;    suffix: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SUFFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;    ptr: ManuallyDrop&amp;lt;NonNull&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;UmbraString {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.len as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;is_empty&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.len == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;default&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#default&quot; aria-label=&quot;Anchor link for: default&quot;&gt;&lt;code&gt;Default&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The empty string is easy to represent: the length is &lt;code&gt;0&lt;&#x2F;code&gt; so it belongs as the inline variant. We&#x27;ll set everything to zero - we won&#x27;t access those bytes so it doesn&#x27;t really matter what they&#x27;re set to, but this seems like a reasonable default.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Default &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;UmbraString {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;default&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            len: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            prefix: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PREFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;            trailing: Trailing {
&lt;&#x2F;span&gt;&lt;span&gt;                suffix: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SUFFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;allocating&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allocating&quot; aria-label=&quot;Anchor link for: allocating&quot;&gt;Allocating&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s define some helper functions for actually allocating the data. The allocation helpers are only used when working with the long variant. A &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; is a &lt;code&gt;&amp;amp;[u8]&lt;&#x2F;code&gt; that is valid UTF-8 so we&#x27;ll be working in terms of &lt;code&gt;*mut u8&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;*const u8&lt;&#x2F;code&gt; thin pointers.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::alloc;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::ptr::{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, NonNull};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;copy_slice&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;src&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;]) -&amp;gt; NonNull&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; layout = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;layout&lt;&#x2F;span&gt;&lt;span&gt;(src.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; nullable = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ alloc::alloc(layout) };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;NonNull::new(nullable) {
&lt;&#x2F;span&gt;&lt;span&gt;        Some(ptr) =&amp;gt; ptr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;cast&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;        None =&amp;gt; alloc::handle_alloc_error(layout),
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        ptr::copy_nonoverlapping(src.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;(), ptr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;(), source.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    ptr
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;layout&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; alloc::Layout {
&lt;&#x2F;span&gt;&lt;span&gt;    alloc::Layout::array::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(len)
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;expect&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a valid layout for an array&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pad_to_align&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;copy_slice&lt;&#x2F;code&gt; allocates an array of bytes on the heap and then copies the source byte slice into our new array, and returns the pointer.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;instantiation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#instantiation&quot; aria-label=&quot;Anchor link for: instantiation&quot;&gt;Instantiation&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To create an &lt;code&gt;UmbraString&lt;&#x2F;code&gt; we&#x27;ll take an existing &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; as input. This operation could possibly fail if the input string is too long. Let&#x27;s ignore that for now and just &lt;code&gt;assert!&lt;&#x2F;code&gt; that the string is not too long:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;From&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;UmbraString {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;from&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;src&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;src) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        assert!(src.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;() &amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;MAX &lt;&#x2F;span&gt;&lt;span&gt;as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; len = src.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; prefix = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PREFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; trailing = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; len as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16 &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;INLINE_LEN &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; suffix = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SUFFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; len &amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PREFIX_LEN &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                prefix[..len].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;copy_from_slice&lt;&#x2F;span&gt;&lt;span&gt;(source);
&lt;&#x2F;span&gt;&lt;span&gt;            } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                prefix.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;copy_from_slice&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;source[..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PREFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;]);
&lt;&#x2F;span&gt;&lt;span&gt;                suffix[..len - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PREFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;copy_from_slice&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;source[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PREFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;..]);
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;            Trailing { suffix }
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;copy_slice&lt;&#x2F;span&gt;&lt;span&gt;(source);
&lt;&#x2F;span&gt;&lt;span&gt;            Trailing { ptr: ManuallyDrop::new(ptr) }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            len: len as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            prefix,
&lt;&#x2F;span&gt;&lt;span&gt;            trailing
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For the short variant (&lt;code&gt;src.len() as u16 &amp;lt;= INLINE_LEN&lt;&#x2F;code&gt;) we copy from the source byte slice into however much of the prefix and suffix slices we can fill and leave the rest as &lt;code&gt;0&lt;&#x2F;code&gt;s. (Note that &lt;code&gt;0&lt;&#x2F;code&gt; is a valid representation in UTF-8. See the section below on &lt;code&gt;FlagSet&lt;&#x2F;code&gt;s for more discussion on why this is important.)&lt;&#x2F;p&gt;
&lt;p&gt;For the long variant we&#x27;ll use our &lt;code&gt;copy_slice&lt;&#x2F;code&gt; helper from above to allocate a new byte array pointer.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;reconstructing-a-byte-slice&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#reconstructing-a-byte-slice&quot; aria-label=&quot;Anchor link for: reconstructing-a-byte-slice&quot;&gt;Reconstructing a byte slice&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Did you notice in our &lt;code&gt;copy_slice&lt;&#x2F;code&gt; helper function above that we copy the entire slice into a newly allocated array buffer instead of the part after the prefix? We copied &lt;code&gt;source&lt;&#x2F;code&gt; instead of &lt;code&gt;&amp;amp;source[PREFIX_LEN..]&lt;&#x2F;code&gt;. You might think that we could save some space by only storing the remaining bytes after the prefix - and we could - but that would prevent us from recreating a &lt;code&gt;&amp;amp;[u8]&lt;&#x2F;code&gt; or &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; from an &lt;code&gt;UmbraString&lt;&#x2F;code&gt;. Slices are &lt;strong&gt;contiguous&lt;&#x2F;strong&gt; memory chunks - array layouts in memory. We can&#x27;t create a slice that starts in the &lt;code&gt;prefix&lt;&#x2F;code&gt; field and then continues by following a pointer. All of the data needs to be in one place.&lt;&#x2F;p&gt;
&lt;p&gt;With that in mind, let&#x27;s add a function to get our bytes back:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::{ptr, slice};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;UmbraString {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;as_slice&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &amp;amp;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;] {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.len &amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;INLINE_LEN &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = ptr::from_ref(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ ptr::addr_of!((*ptr).prefix) }.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;cast&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.trailing.ptr }.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ slice::from_raw_parts(ptr, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;()) }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;as_bytes&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &amp;amp;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;] {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_slice&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;as_str&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;str &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ core::str::from_utf8_unchecked(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_slice&lt;&#x2F;span&gt;&lt;span&gt;()) }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For inline Umbra strings our slice starts at the prefix field and ends either in the prefix field&#x27;s array or in the suffix field&#x27;s array depending on the length. The &lt;code&gt;#[repr(C)]&lt;&#x2F;code&gt; annotation on &lt;code&gt;UmbraString&lt;&#x2F;code&gt; and &lt;code&gt;Trailing&lt;&#x2F;code&gt; enforces that when represented in memory at runtime, the fields are in the same order as we define them, so we can safely assume that &lt;code&gt;prefix&lt;&#x2F;code&gt; comes before &lt;code&gt;suffix&lt;&#x2F;code&gt; and there&#x27;s no space between. We can safely treat them as contiguous memory. For allocated strings we reconstruct the slice directly from our allocated buffer&#x27;s pointer.&lt;&#x2F;p&gt;
&lt;p&gt;Remember earlier when we said that slices were basically &lt;code&gt;(*const T, usize)&lt;&#x2F;code&gt;? That&#x27;s what we give to &lt;code&gt;slice::from_raw_parts&lt;&#x2F;code&gt; - a pointer to an array layout in memory and a length - and we get a fat pointer.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;clone&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#clone&quot; aria-label=&quot;Anchor link for: clone&quot;&gt;Clone&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Cloning the string is similar to how we initially created one from a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Clone &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;UmbraString {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; trailing = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.len &amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;INLINE_LEN &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; suffix = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.trailing.suffix };
&lt;&#x2F;span&gt;&lt;span&gt;            Trailing { suffix }
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;copy_slice&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_slice&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;            Trailing { ptr: ManuallyDrop::new(ptr) }
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            len: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.len,
&lt;&#x2F;span&gt;&lt;span&gt;            prefix: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.prefix,
&lt;&#x2F;span&gt;&lt;span&gt;            trailing,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;len&lt;&#x2F;code&gt; and &lt;code&gt;prefix&lt;&#x2F;code&gt; fields are copied. For the inline version we copy the &lt;code&gt;suffix&lt;&#x2F;code&gt; array too, and for the allocated version we create a new allocation and copy &lt;code&gt;self&lt;&#x2F;code&gt;&#x27;s buffer.&lt;&#x2F;p&gt;
&lt;p&gt;Another nice property of this type you might notice here: for strings short enough to be inlined, &lt;code&gt;Clone&lt;&#x2F;code&gt; is actually a &lt;code&gt;Copy&lt;&#x2F;code&gt; - no allocation required.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;drop&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#drop&quot; aria-label=&quot;Anchor link for: drop&quot;&gt;Drop&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now on to &lt;code&gt;Drop&lt;&#x2F;code&gt;. We need to deallocate our allocated buffer for the long variant. For the short variant we do nothing: &lt;code&gt;Copy&lt;&#x2F;code&gt; types are cleaned up without any mention in &lt;code&gt;Drop&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Drop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;UmbraString {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;drop&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.len &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;INLINE_LEN &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; layout = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;layout&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.trailing.ptr }.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ alloc::dealloc(ptr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;cast&lt;&#x2F;span&gt;&lt;span&gt;(), layout);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;eq&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#eq&quot; aria-label=&quot;Anchor link for: eq&quot;&gt;&lt;code&gt;Eq&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;As the CedarDB article notes, we can optimize the comparison of Umbra strings. To do that we cast the &lt;code&gt;len&lt;&#x2F;code&gt; and &lt;code&gt;prefix&lt;&#x2F;code&gt; chunks together as a &lt;code&gt;usize&lt;&#x2F;code&gt; and compare those, and then compare the remaining parts of the string if that first word of memory is equal. We don&#x27;t use the &lt;code&gt;Eq&lt;&#x2F;code&gt; optimization in Spellbook since Umbra strings are only used for the lookup table representation (we use &lt;code&gt;PartialEq&amp;lt;str&amp;gt; for UmbraString&lt;&#x2F;code&gt; instead), but it&#x27;s interesting from an academic perspective.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;PartialEq&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;UmbraString {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;eq&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;other&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; self_len_and_prefix = ptr::from_ref(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;).cast::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; other_len_and_prefix = ptr::from_ref(other).cast::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ *self_len_and_prefix != *other_len_and_prefix } {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; The lengths and prefixes are equal. Now compare the rest.
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.len &amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;INLINE_LEN &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; We can use the same trick as above: compare the suffixes as one big chunk.
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; self_ptr = ptr::from_ref(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; self_suffix = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ ptr::addr_of!((*self_ptr).trailing.suffix) }.cast::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;();
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; other_ptr = ptr::from_ref(other);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; other_suffix = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ ptr::addr_of!((*other_ptr).trailing.suffix) }.cast::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ *self_suffix == *other_suffix }
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; suffix_len = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;() - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PREFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; self_rest = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                slice::from_raw_parts(
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.trailing.ptr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PREFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;                    suffix_len
&lt;&#x2F;span&gt;&lt;span&gt;                )
&lt;&#x2F;span&gt;&lt;span&gt;            };
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; other_rest = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                slice::from_raw_parts(
&lt;&#x2F;span&gt;&lt;span&gt;                    other.trailing.ptr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PREFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;                    suffix_len
&lt;&#x2F;span&gt;&lt;span&gt;                )
&lt;&#x2F;span&gt;&lt;span&gt;            };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;            self_rest == other_rest
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Eq &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;UmbraString {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We start by comparing the length and prefix parts together with one &lt;code&gt;usize&lt;&#x2F;code&gt; comparison. If that is equal then we need to check the rest. For the short variant we can use another &lt;code&gt;usize&lt;&#x2F;code&gt; comparison to check the rest. For the long variant we can reconstruct the byte slices for the remaining bytes and compare those.&lt;&#x2F;p&gt;
&lt;p&gt;We can actually make this a little better. We know in that &lt;code&gt;else&lt;&#x2F;code&gt; block that the lengths of &lt;code&gt;self&lt;&#x2F;code&gt; and &lt;code&gt;other&lt;&#x2F;code&gt; are equal but comparing the byte slices (&lt;code&gt;PartialEq&amp;lt;Self&amp;gt; for &amp;amp;[T]&lt;&#x2F;code&gt;) will repeat that check. We can skip that check and do the comparison directly. Since &lt;code&gt;u8&lt;&#x2F;code&gt;s are byte-wise equal to each other, we can use &lt;code&gt;memcmp&lt;&#x2F;code&gt; like the standard library does.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;PartialEq&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;UmbraString {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;eq&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;other&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ... unchanged ...
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.len &amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;INLINE_LEN &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ... unchanged ...
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; suffix_n_bytes = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;() - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PREFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;memcmp&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.trailing.ptr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PREFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;                    other.trailing.ptr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ptr&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PREFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;                    suffix_n_bytes,
&lt;&#x2F;span&gt;&lt;span&gt;                ) == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Snipped from `library&#x2F;core&#x2F;src&#x2F;slice&#x2F;cmp.rs`:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; Calls implementation provided memcmp.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; Interprets the data as u8.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; Returns 0 for equal, &amp;lt; 0 for less than and &amp;gt; 0 for greater
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; than.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;memcmp&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;s1&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const u8&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;s2&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const u8&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; core::ffi::c_int;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;benchmarking-and-memory-analysis&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#benchmarking-and-memory-analysis&quot; aria-label=&quot;Anchor link for: benchmarking-and-memory-analysis&quot;&gt;Benchmarking and memory analysis&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;Speed benchmarks are unfortunately not very interesting. Spellbook doesn&#x27;t take advantage of the &lt;code&gt;Eq&lt;&#x2F;code&gt; comparison so we only end up paying for the conversion in &lt;code&gt;UmbraString::as_slice&lt;&#x2F;code&gt;. This is nearly imperceptibly slower than &lt;code&gt;Box&amp;lt;str&amp;gt;::as_bytes&lt;&#x2F;code&gt;. Using &lt;code&gt;cargo bench&lt;&#x2F;code&gt; and simple benchmarks like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; NOTE: this needs nightly.
&lt;&#x2F;span&gt;&lt;span&gt;#![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;feature&lt;&#x2F;span&gt;&lt;span&gt;(test)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span&gt; test;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;test::{black_box, Bencher};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;spellbook::umbra_slice::UmbraString;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bench&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;umbra_str_as_bytes&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; Bencher) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; s: UmbraString = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;repeat&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;50&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    b.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;(|| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;black_box&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;s).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_bytes&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bench&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;boxed_str_as_bytes&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; Bencher) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; s: Box&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;repeat&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;50&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    b.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;(|| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;black_box&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;s).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_bytes&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;umbra_str_as_bytes&lt;&#x2F;code&gt; measures at around 0.69 ns&#x2F;iter on my machine while &lt;code&gt;boxed_str_as_bytes&lt;&#x2F;code&gt; measures around 0.46 ns&#x2F;iter. We would need to be converting to bytes very very often to notice the difference, and Spellbook doesn&#x27;t ultimately convert that often. The benchmarks for Spellbook&#x27;s &lt;code&gt;check&lt;&#x2F;code&gt; function don&#x27;t change perceptibly.&lt;&#x2F;p&gt;
&lt;p&gt;Where we see the difference is in memory usage and heap interaction. Measuring heap allocations is not as straightforward in Rust as you might imagine if you&#x27;re coming from garbage collected languages: garbage collectors need to track the heap to know when to clean up garbage so there&#x27;s typically an interface to query heap information. Not so with Rust. &lt;a href=&quot;https:&#x2F;&#x2F;rust-analyzer.github.io&#x2F;blog&#x2F;2020&#x2F;12&#x2F;04&#x2F;measuring-memory-usage-in-rust.html&quot;&gt;Measuring Memory Usage in Rust&lt;&#x2F;a&gt; from the &lt;code&gt;rust-analyzer&lt;&#x2F;code&gt; blog points out a few options. Of them I&#x27;m partial to &lt;code&gt;valgrind&lt;&#x2F;code&gt;&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;valgrind.org&#x2F;docs&#x2F;manual&#x2F;dh-manual.html&quot;&gt;DHAT&lt;&#x2F;a&gt; tool since it&#x27;s straightforward to use.&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ll run a small example program that creates the &lt;code&gt;en_US&lt;&#x2F;code&gt; dictionary and checks a single word:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cargo&lt;&#x2F;span&gt;&lt;span&gt; run&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --release --example&lt;&#x2F;span&gt;&lt;span&gt; check hello
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;valgrind --tool&lt;&#x2F;span&gt;&lt;span&gt;=dhat .&#x2F;target&#x2F;release&#x2F;examples&#x2F;check hello
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Before (&lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; stems), DHAT reports:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Total:     3,086,190 bytes in 130,988 blocks
&lt;&#x2F;span&gt;&lt;span&gt;At t-gmax: 2,717,005 bytes in 90,410 blocks
&lt;&#x2F;span&gt;&lt;span&gt;At t-end:  0 bytes in 0 blocks
&lt;&#x2F;span&gt;&lt;span&gt;Reads:     3,923,475 bytes
&lt;&#x2F;span&gt;&lt;span&gt;Writes:    2,610,900 bytes
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;After (&lt;code&gt;UmbraString&lt;&#x2F;code&gt; stems):&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Total:     2,714,546 bytes in 82,475 blocks
&lt;&#x2F;span&gt;&lt;span&gt;At t-gmax: 2,343,567 bytes in 41,487 blocks
&lt;&#x2F;span&gt;&lt;span&gt;At t-end:  0 bytes in 0 blocks
&lt;&#x2F;span&gt;&lt;span&gt;Reads:     2,332,587 bytes
&lt;&#x2F;span&gt;&lt;span&gt;Writes:    2,239,256 bytes
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;ve saved around 300kb of total runtime memory (12%) with the change, plus we&#x27;re using fewer blocks of memory and reading from and writing to the heap less. Success!&lt;&#x2F;p&gt;
&lt;p&gt;We can go further though if we apply this &quot;German string&quot; optimization to another oft-instantiated type in the lookup table: the &lt;code&gt;FlagSet&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;bonus-points-the-flagset-can-also-be-german&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#bonus-points-the-flagset-can-also-be-german&quot; aria-label=&quot;Anchor link for: bonus-points-the-flagset-can-also-be-german&quot;&gt;Bonus points: the FlagSet can also be German!&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;Remember way back at the beginning of the post when were discussing the lookup table and how it&#x27;s like a &lt;code&gt;HashMap&amp;lt;String, HashSet&amp;lt;Flag&amp;gt;&amp;gt;&lt;&#x2F;code&gt;? The &lt;code&gt;HashSet&amp;lt;Flag&amp;gt;&lt;&#x2F;code&gt; part is defined in the Spellbook source as a &lt;code&gt;FlagSet&lt;&#x2F;code&gt; newtype wrapper. It doesn&#x27;t wrap a &lt;code&gt;HashSet&amp;lt;Flag&amp;gt;&lt;&#x2F;code&gt; though - hash sets can be wasteful in terms of memory usage. Before the Umbra string optimization they were represented as &lt;code&gt;Box&amp;lt;[Flag]&amp;gt;&lt;&#x2F;code&gt;. For short slices, &lt;code&gt;slice::contains&lt;&#x2F;code&gt; or &lt;code&gt;slice::binary_search&lt;&#x2F;code&gt; are very fast at determining set membership.&lt;&#x2F;p&gt;
&lt;p&gt;Like stems, flagsets are usually short. If we measure a histogram of the number of flags used per stem in all dictionaries in &lt;code&gt;LibreOffice&#x2F;dictionaries&lt;&#x2F;code&gt;, we see the distribution skew &lt;strong&gt;very&lt;&#x2F;strong&gt; short:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Number of flags&lt;&#x2F;th&gt;&lt;th&gt;Percentile (rounded)&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;32&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;69&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;80&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;td&gt;86&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;90&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;...&lt;&#x2F;td&gt;&lt;td&gt;...&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;7&lt;&#x2F;td&gt;&lt;td&gt;96&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;...&lt;&#x2F;td&gt;&lt;td&gt;...&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;One crazy dictionary used 271 flags on a single stem.&lt;&#x2F;p&gt;
&lt;p&gt;So if we can store some number of flags inline like we did with bytes an Umbra string, we can avoid allocations in the vast majority of cases.&lt;&#x2F;p&gt;
&lt;p&gt;Rather than an &quot;Umbra string&quot; we&#x27;ll be constructing a more generic &quot;Umbra slice&quot; type. In fact we can imagine that the &lt;code&gt;UmbraString&lt;&#x2F;code&gt; is just a special case of an &lt;code&gt;UmbraSlice&lt;&#x2F;code&gt; around bytes:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; These bytes are valid UTF-8.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;UmbraString(UmbraSlice&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The new type comes with new challenges though. For... &lt;em&gt;reasons&lt;&#x2F;em&gt;... &lt;code&gt;Flag&lt;&#x2F;code&gt; is defined as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;Flag = core::num::NonZeroU16;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So rather than dealing with bytes we need to deal with 16-bit integers. Ok, that changes the arithmetic a little:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; We can fit 3 u16s in the prefix.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;prefix_len&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Remove 16 bits for the `len`.
&lt;&#x2F;span&gt;&lt;span&gt;    (size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;() - size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;()) &#x2F; size_of::&amp;lt;T&amp;gt;()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; And 4 in the suffix.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;suffix_len&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;() &#x2F; size_of::&amp;lt;T&amp;gt;()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can fit up to 7 flags inline. That&#x27;s really awesome: it&#x27;ll cover up to 96% of real-world flagsets and should save us many many really tiny allocations.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pitfalls-and-maybeuninit-t&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#pitfalls-and-maybeuninit-t&quot; aria-label=&quot;Anchor link for: pitfalls-and-maybeuninit-t&quot;&gt;Pitfalls and &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We&#x27;re talking in terms of &lt;code&gt;u16&lt;&#x2F;code&gt; above but our type is actually a &lt;code&gt;NonZeroU16&lt;&#x2F;code&gt;. They have the same size and layout but &lt;code&gt;NonZeroU16&lt;&#x2F;code&gt; can&#x27;t be &lt;code&gt;0u16&lt;&#x2F;code&gt;. The challenge is the &lt;code&gt;NonZero&lt;&#x2F;code&gt; nature: the zeroed bit pattern is not a valid representation, and &lt;code&gt;Default for NonZeroU16&lt;&#x2F;code&gt; is not a thing. Places where we wrote &lt;code&gt;[0u8; N]&lt;&#x2F;code&gt; above have to be rewritten anyways since we&#x27;re changing the type, but we can&#x27;t just say:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ðŸ’£ UNDEFINED BEHAVIOR!!
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; prefix: [T; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PREFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;] = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ core::mem::zeroed() };
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; suffix: [T; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SUFFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;] = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ core::mem::zeroed() };
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You can&#x27;t say that a value is a &lt;code&gt;NonZeroU16&lt;&#x2F;code&gt; and at the same time represent it with zeroes, even if you never formally access those elements of the array. The proper way to encode what we&#x27;re trying to do is to use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;mem&#x2F;union.MaybeUninit.html&quot;&gt;MaybeUninit&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::mem::MaybeUninit;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use crate&lt;&#x2F;span&gt;&lt;span&gt;::Flag;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Unfortunately we cannot call `prefix_len`&#x2F;`suffix_len` within
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; the definition of `UmbraSlice` so we need to use const generics.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; The result is that this type is not pretty :&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span&gt;FlagSlice = UmbraSlice&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;    Flag,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;{&lt;&#x2F;span&gt;&lt;span&gt; prefix_len::&amp;lt;Flag&amp;gt;() },
&lt;&#x2F;span&gt;&lt;span&gt;    { suffix_len::&amp;lt;Flag&amp;gt;() },
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;repr&lt;&#x2F;span&gt;&lt;span&gt;(C)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;UmbraSlice&amp;lt;T: Copy, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; PREFIX_LEN: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; SUFFIX_LEN: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prefix&lt;&#x2F;span&gt;&lt;span&gt;: [MaybeUninit&amp;lt;T&amp;gt;; PREFIX_LEN],
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;trailing&lt;&#x2F;span&gt;&lt;span&gt;: Trailing&amp;lt;T, SUFFIX_LEN&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;repr&lt;&#x2F;span&gt;&lt;span&gt;(C)]
&lt;&#x2F;span&gt;&lt;span&gt;union Trailing&amp;lt;T: Copy&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SUFFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    suffix: [MaybeUninit&amp;lt;T&amp;gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SUFFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;    ptr: ManuallyDrop&amp;lt;NonNull&amp;lt;T&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: Copy, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; PREFIX_LEN: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; SUFFIX_LEN: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    UmbraSlice&amp;lt;T, PREFIX_LEN, SUFFIX_LEN&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;INLINE_LEN&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16 &lt;&#x2F;span&gt;&lt;span&gt;= (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PREFIX_LEN &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SUFFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;) as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This makes the type slightly harder to work with: when accessing the &lt;code&gt;prefix&lt;&#x2F;code&gt; and &lt;code&gt;suffix&lt;&#x2F;code&gt; arrays we need to be sure to &lt;code&gt;ptr::cast()&lt;&#x2F;code&gt; from a pointer of &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; to a pointer of &lt;code&gt;T&lt;&#x2F;code&gt;. When initializing the slice in our &lt;code&gt;From&lt;&#x2F;code&gt; implementation we need to transmute the source slice from &lt;code&gt;&amp;amp;[T]&lt;&#x2F;code&gt; to &lt;code&gt;&amp;amp;[MaybeUninit&amp;lt;T&amp;gt;]&lt;&#x2F;code&gt; before we can copy the data:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;copy_to_slice&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: Copy&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dst&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; [MaybeUninit&amp;lt;T&amp;gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;src&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;[T]) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; SAFETY: &amp;amp;[T] and &amp;amp;[MaybeUninit&amp;lt;T&amp;gt;] have the same layout.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; uninit_src: &amp;amp;[MaybeUninit&amp;lt;T&amp;gt;] = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ core::mem::transmute(src) };
&lt;&#x2F;span&gt;&lt;span&gt;    dst.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;copy_from_slice&lt;&#x2F;span&gt;&lt;span&gt;(uninit_src);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;zeroed-bit-patterns&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#zeroed-bit-patterns&quot; aria-label=&quot;Anchor link for: zeroed-bit-patterns&quot;&gt;Zeroed bit patterns&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We also need to be &lt;strong&gt;very&lt;&#x2F;strong&gt; careful to initialize &lt;code&gt;prefix&lt;&#x2F;code&gt; and &lt;code&gt;suffix&lt;&#x2F;code&gt; with &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;::zeroed()&lt;&#x2F;code&gt; rather than &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;::uninit()&lt;&#x2F;code&gt;. Why? Remember that our &lt;code&gt;PartialEq&amp;lt;Self&amp;gt;&lt;&#x2F;code&gt; implementation compares the prefix array and maybe also the suffix array for the short variant. Those arrays might contain uninitialized data if the length of the slice is shorter than the &lt;code&gt;INLINE_LEN&lt;&#x2F;code&gt; or &lt;code&gt;PREFIX_LEN&lt;&#x2F;code&gt;. &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;::zeroed()&lt;&#x2F;code&gt; works around this because comparing zeroed bits is defined behavior. The important distinction is that we are not treating the zeroed memory as &lt;code&gt;NonZeroU16&lt;&#x2F;code&gt;. That is undefined behavior. If we treat it as a &lt;code&gt;usize&lt;&#x2F;code&gt; though, the zeroed bit pattern is valid and the behavior is defined. It&#x27;s also accurate as long as &lt;code&gt;T&lt;&#x2F;code&gt; is &lt;code&gt;Copy&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Note that `T` is not bound by `Eq`.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; We only ever compare bits, not `T`s.
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: Copy, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; PREFIX_LEN: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; SUFFIX_LEN: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; PartialEq&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for UmbraSlice&amp;lt;T, PREFIX_LEN, SUFFIX_LEN&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;eq&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;other&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; SAFETY: the `prefix` field is created with `MaybeUninit::zeroed` memory, so even
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; if the slice has fewer than `PREFIX_LEN` elements, comparing the uninitialized
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; memory is defined behavior, and it is accurate since `T` is `Copy`.
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; self_len_and_prefix = ptr::from_ref(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;).cast::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; other_len_and_prefix = ptr::from_ref(other).cast::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ *self_len_and_prefix != *other_len_and_prefix } {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ... compare suffixes ...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;null-pointer-optimization-and-strange-behavior&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#null-pointer-optimization-and-strange-behavior&quot; aria-label=&quot;Anchor link for: null-pointer-optimization-and-strange-behavior&quot;&gt;Null pointer optimization and strange behavior&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;What exactly can go wrong if you don&#x27;t use &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;? The compiler can see that &lt;code&gt;NonZeroU16&lt;&#x2F;code&gt; cannot ever be a zeroed bit pattern and it can design the layouts for other types using &lt;code&gt;FlagSlice&lt;&#x2F;code&gt; around that. If we designed our type like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;repr&lt;&#x2F;span&gt;&lt;span&gt;(C)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;FlagSlice {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prefix&lt;&#x2F;span&gt;&lt;span&gt;: [Flag; PREFIX_LEN],
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;trailing&lt;&#x2F;span&gt;&lt;span&gt;: Trailing,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;repr&lt;&#x2F;span&gt;&lt;span&gt;(C)]
&lt;&#x2F;span&gt;&lt;span&gt;union Trailing {
&lt;&#x2F;span&gt;&lt;span&gt;    suffix: [Flag; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SUFFIX_LEN&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;    ptr: ManuallyDrop&amp;lt;NonNull&amp;lt;Flag&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then &lt;code&gt;FlagSlice&lt;&#x2F;code&gt; is eligible for the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;option&#x2F;index.html#representation&quot;&gt;null pointer memory layout optimization&lt;&#x2F;a&gt;. The compiler can tell that the zero bit pattern is not a valid representation for the struct and so it can try to fit other information in that representation, like whether an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; is &lt;code&gt;Some&lt;&#x2F;code&gt; or &lt;code&gt;None&lt;&#x2F;code&gt;. It&#x27;s a really handy optimization that makes &lt;code&gt;size_of::&amp;lt;Option&amp;lt;T&amp;gt;&amp;gt;() == size_of::&amp;lt;T&amp;gt;()&lt;&#x2F;code&gt; - you don&#x27;t pay for the option. But how would you represent the empty flag slice?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ðŸ’£ UNDEFINED BEHAVIOR!!
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Default &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;FlagSlice {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;default&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            len: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            prefix: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ core::mem::zeroed() },
&lt;&#x2F;span&gt;&lt;span&gt;            trailing: Trailing {
&lt;&#x2F;span&gt;&lt;span&gt;                suffix: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ core::mem::zeroed() },
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The length is zero, the prefix is zeroes, the suffix is zeroes. The whole struct is zeroes! With this representation, &lt;code&gt;Option::&amp;lt;FlagSlice&amp;gt;::None&lt;&#x2F;code&gt; is exactly the same as &lt;code&gt;FlagSlice::default()&lt;&#x2F;code&gt;, causing your code to behave &lt;em&gt;weirdly&lt;&#x2F;em&gt;. Suddenly &lt;code&gt;Some(FlagSlice::default()).is_some()&lt;&#x2F;code&gt; is &lt;code&gt;false&lt;&#x2F;code&gt;! ðŸ¥´&lt;&#x2F;p&gt;
&lt;p&gt;While this pitfall seems scary and hard to debug, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;miri&quot;&gt;Miri&lt;&#x2F;a&gt; has got your back. Write types without the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; wrapper and &lt;code&gt;cargo miri test&lt;&#x2F;code&gt; will helpfully point out that you&#x27;re opening yourself up to undefined behavior.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;flagslice-memory-savings&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#flagslice-memory-savings&quot; aria-label=&quot;Anchor link for: flagslice-memory-savings&quot;&gt;FlagSlice Memory Savings&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Rerunning the same example from above, DHAT reports:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Total:     2,584,850 bytes in 44,741 blocks
&lt;&#x2F;span&gt;&lt;span&gt;At t-gmax: 2,190,833 bytes in 947 blocks
&lt;&#x2F;span&gt;&lt;span&gt;At t-end:  0 bytes in 0 blocks
&lt;&#x2F;span&gt;&lt;span&gt;Reads:     1,733,361 bytes
&lt;&#x2F;span&gt;&lt;span&gt;Writes:    2,109,560 bytes
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So to compare:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Stem + FlagSet&lt;&#x2F;th&gt;&lt;th&gt;Total&lt;&#x2F;th&gt;&lt;th&gt;At t-gmax&lt;&#x2F;th&gt;&lt;th&gt;Reads (B)&lt;&#x2F;th&gt;&lt;th&gt;Writes (B)&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; + &lt;code&gt;Box&amp;lt;[Flag]&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;3,086,190 bytes in 130,988 blocks&lt;&#x2F;td&gt;&lt;td&gt;2,717,005 bytes in 90,410 blocks&lt;&#x2F;td&gt;&lt;td&gt;3,923,475&lt;&#x2F;td&gt;&lt;td&gt;2,610,900&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;UmbraString&lt;&#x2F;code&gt; + &lt;code&gt;Box&amp;lt;[Flag]&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;2,714,546 bytes in 82,475 blocks&lt;&#x2F;td&gt;&lt;td&gt;2,343,567 bytes in 41,487 blocks&lt;&#x2F;td&gt;&lt;td&gt;2,332,587&lt;&#x2F;td&gt;&lt;td&gt;2,239,256&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;UmbraString&lt;&#x2F;code&gt; + &lt;code&gt;FlagSlice&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;2,584,850 bytes in 44,741 blocks&lt;&#x2F;td&gt;&lt;td&gt;2,190,833 bytes in 947 blocks&lt;&#x2F;td&gt;&lt;td&gt;1,733,361&lt;&#x2F;td&gt;&lt;td&gt;2,109,560&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;These are some respectable savings! We&#x27;ve cut out about a half of a megabyte of total memory, used far fewer allocations (blocks) and write to the heap a fair amount less. Plus we read from the heap less than half as much as we did before the changes.&lt;&#x2F;p&gt;
&lt;p&gt;Not every dictionary will see the same savings, though: some dictionaries use more flags and have longer stems. But as discussed above, every time we use a short variant of an Umbra slice we save memory over a &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; or &lt;code&gt;Box&amp;lt;[Flag]&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;wrapping-up-kudos&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#wrapping-up-kudos&quot; aria-label=&quot;Anchor link for: wrapping-up-kudos&quot;&gt;Wrapping up &amp;amp; Kudos&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;We&#x27;ve designed and implemented a German string inspired &lt;code&gt;UmbraSlice&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; type that can carry a small number of &lt;code&gt;T&lt;&#x2F;code&gt;s inline - a small &lt;em&gt;slice&lt;&#x2F;em&gt; optimization - and used it to save a respectable amount of total memory for the &lt;code&gt;Dictionary&lt;&#x2F;code&gt; type, and also cut way down on heap interaction. We&#x27;ve also stumbled upon lots of interesting detours into Rust topics: fat pointers, runtime memory measurement, &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; and the null-pointer optimization. The full code for &lt;code&gt;UmbraSlice&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; lives in Spellbook&#x27;s repository in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;helix-editor&#x2F;spellbook&#x2F;blob&#x2F;master&#x2F;src&#x2F;umbra_slice.rs&quot;&gt;&lt;code&gt;src&#x2F;umbra_slice.rs&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;As mentioned above, CedarDB has an excellent &lt;a href=&quot;https:&#x2F;&#x2F;cedardb.com&#x2F;blog&#x2F;german_strings&#x2F;&quot;&gt;intro post for German strings&lt;&#x2F;a&gt; and also a nice &lt;a href=&quot;https:&#x2F;&#x2F;cedardb.com&#x2F;blog&#x2F;strings_deep_dive&#x2F;&quot;&gt;deeper dive&lt;&#x2F;a&gt;. The former has a snide remark about an optimization which is supposedly impossible in Rust, provoking interesting response posts by those who had been successfully nerd-sniped. One of these - &lt;a href=&quot;https:&#x2F;&#x2F;tunglevo.com&#x2F;note&#x2F;an-optimization-thats-impossible-in-rust&#x2F;&quot;&gt;An Optimization That&#x27;s Impossible in Rust!&lt;&#x2F;a&gt; - I found very informative on the Rust aspects of implementing German strings, and may be interesting if your use-case benefits from &lt;code&gt;Clone for UmbraString&lt;&#x2F;code&gt; being cheap like &lt;code&gt;Clone for Arc&lt;&#x2F;code&gt;. (Not so for Spellbook.) Thank you to these authors!&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
